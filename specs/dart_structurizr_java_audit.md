# Dart Structurizr vs Java Structurizr DSL Audit Table

| Dart Module/Class/Method | Java Equivalent | Notes/Differences | Audit Status | Refactoring Plan | Testing Plan | Testing Methods | Comprehensive Implementation Plan | Parsing Implementation Methods |
|-------------------------|----------------|-------------------|--------------|------------------|--------------|-----------------|-------------------------------|-----------------------------|
| `Parser.parse()` (`lib/domain/parser/parser.dart`) | `StructurizrDslParser.parse()` | Entry point for parsing. Dart is monolithic, Java is modular. Error/context handling less robust in Dart. | Needs modularization, context stack, error handling review | **1. Refactor parser into submodules (ModelParser, ViewsParser, etc.). 2. Implement a class-based context stack for granular context switching. 3. Modularize error handling and recovery, mirroring Java. 4. Add/expand tests for error recovery and context transitions. 5. Add debug output for all context switches and error events.** | **Unit: Test all entry points with valid/invalid DSL, including deeply nested and malformed input. Integration: Parse full DSL files (from Structurizr test suite) and compare AST/model output to Java. Error: Fuzz test with random tokens, missing braces, invalid keywords. Regression: Add golden tests for known bugfixes. Coverage: 100% of all code paths, including error recovery.** | **test('parse_valid_dsl', () { ... }); test('parse_invalid_dsl', () { ... }); test('parse_deeply_nested', () { ... }); test('parse_malformed_input', () { ... }); test('parse_structurizr_suite', () { ... }); test('parse_fuzz', () { ... }); test('parse_error_recovery', () { ... }); test('parse_regression_bugX', () { ... });** | **1. Refactor the parser into modular subcomponents (e.g., ModelParser, ViewsParser, RelationshipParser) with clear interfaces. 2. Implement a class-based context stack for managing parsing state, mirroring Java's context management. 3. Modularize error handling and recovery logic, ensuring robust error context and reporting. 4. Integrate submodules into a unified parsing pipeline. 5. Add comprehensive debug output for all context switches and error events. 6. Update documentation to reflect the new modular parser architecture and error handling.** | **parse(String dsl): WorkspaceNode; ModelParser.parse(List<Token>): ModelNode; ViewsParser.parse(List<Token>): ViewsNode; RelationshipParser.parse(List<Token>): List<RelationshipNode>; ContextStack.push(Context ctx): void; ContextStack.pop(): Context; handleError(ParseError err): void; integrateSubmodules(): void;** |
| `_parseModel()` | `ModelParser.parse()` | Dart recently added implicit relationships; may lack group/enterprise support. | Needs group/enterprise support, more tests | **1. Analyze the Java ModelParser for all features, including groups, enterprise boundaries, and nested elements. 2. Implement group and enterprise support in the Dart model parser, ensuring correct AST and model representation. 3. Refactor the model node structure to support arbitrary nesting and grouping. 4. Add logic for handling implied relationships and advanced model features. 5. Integrate new features with the rest of the parsing pipeline. 6. Update documentation to describe group/enterprise/nesting support.** | **Unit: Test parsing of all model node types (person, system, group, enterprise, nested). Edge: Test deeply nested/grouped models, implied relationships. Integration: Parse real-world DSLs with complex models. Regression: Golden tests for model AST output. Coverage: 100% of model node types and relationships.** | **test('parse_model_person', () { ... }); test('parse_model_software_system', () { ... }); test('parse_model_group', () { ... }); test('parse_model_enterprise', () { ... }); test('parse_model_nested', () { ... }); test('parse_model_implied_relationships', () { ... }); test('parse_model_deep_nesting', () { ... }); test('parse_model_regression_bugY', () { ... });** | **1. Analyze the Java ModelParser for all features, including groups, enterprise boundaries, and nested elements. 2. Implement group and enterprise support in the Dart model parser, ensuring correct AST and model representation. 3. Refactor the model node structure to support arbitrary nesting and grouping. 4. Add logic for handling implied relationships and advanced model features. 5. Integrate new features with the rest of the parsing pipeline. 6. Update documentation to describe group/enterprise/nesting support.** | **ModelParser.parse(List<Token>): ModelNode; ModelParser._parseGroup(List<Token>): GroupNode; ModelParser._parseEnterprise(List<Token>): EnterpriseNode; ModelParser._parseNestedElement(List<Token>): ElementNode; ModelParser._parseImpliedRelationship(List<Token>): RelationshipNode; ModelNode.addGroup(GroupNode): void; ModelNode.addEnterprise(EnterpriseNode): void; ModelNode.addElement(ElementNode): void;** |
| `_parseViews()` | `ViewsParser.parse()` | Dart may misparse view-level properties (e.g. theme) as includes. Java supports view inheritance, advanced include/exclude. | Needs property parsing fix, inheritance, advanced include/exclude | **1. Refactor the view parsing logic to clearly separate view-level properties from view blocks. 2. Implement view inheritance and advanced include/exclude logic, matching Java's feature set. 3. Update the AST and model to support new view features. 4. Integrate view parsing changes with the rest of the parser and builder. 5. Add detailed debug output for property parsing and inheritance. 6. Update documentation to reflect new view parsing and inheritance logic.** | **Unit: Test all view types, property parsing, include/exclude logic. Edge: Test view inheritance, conflicting includes/excludes, missing/extra properties. Integration: Parse DSLs with multiple/complex views. Regression: Golden tests for view AST output. Coverage: 100% of view features and error cases.** | **test('parse_views_system_context', () { ... }); test('parse_views_container', () { ... }); test('parse_views_dynamic', () { ... }); test('parse_views_deployment', () { ... }); test('parse_views_theme_property', () { ... }); test('parse_views_inheritance', () { ... }); test('parse_views_include_exclude', () { ... }); test('parse_views_conflicting_rules', () { ... }); test('parse_views_regression_bugZ', () { ... });** | **ViewsParser.parse(List<Token>): ViewsNode; ViewsParser._parseViewBlock(List<Token>): ViewNode; ViewsParser._parseViewProperty(List<Token>): ViewPropertyNode; ViewsParser._parseInheritance(List<Token>): void; ViewsParser._parseIncludeExclude(List<Token>): void; ViewsNode.addView(ViewNode): void; ViewNode.setProperty(ViewPropertyNode): void;** |
| `_parsePerson()`, `_parseSoftwareSystem()` | `ElementParser.parsePerson()`, `parseSoftwareSystem()` | Dart may be stricter on identifiers, less flexible on parent/child relationships. | Needs identifier/parent-child audit | **1. Audit Java element parsing for identifier and parent/child relationship handling. 2. Refactor Dart element parsing to allow flexible identifiers and support parent/child nesting as in Java. 3. Update the AST and model to support new element relationships. 4. Integrate changes with model and parser. 5. Add debug output for element parsing and parent/child relationships. 6. Update documentation to describe identifier and nesting logic.** | **Unit: Test all element types, identifier rules, parent/child nesting. Edge: Test invalid identifiers, deeply nested elements, circular references. Integration: Parse DSLs with complex element hierarchies. Regression: Golden tests for element AST output. Coverage: 100% of element types and nesting scenarios.** | **test('parse_element_person', () { ... }); test('parse_element_software_system', () { ... }); test('parse_element_identifier_rules', () { ... }); test('parse_element_parent_child', () { ... }); test('parse_element_deep_nesting', () { ... }); test('parse_element_circular_reference', () { ... }); test('parse_element_regression_bugA', () { ... });** | **ElementParser.parsePerson(List<Token>): PersonNode; ElementParser.parseSoftwareSystem(List<Token>): SoftwareSystemNode; ElementParser._parseIdentifier(List<Token>): String; ElementParser._parseParentChild(List<Token>): void; ElementNode.addChild(ElementNode): void; ElementNode.setIdentifier(String): void;** |
| `_parseRelationship()`, `_parseImplicitRelationship()` | `RelationshipParser.parse()` | Dart only recently added implicit relationships, may not support all edge cases. | Needs edge case tests, group/nested support | **1. Analyze Java relationship parsing for all edge cases, including groups, nested, implied, and circular relationships. 2. Implement missing relationship logic in Dart, ensuring correct AST and model representation. 3. Refactor relationship parsing to support all valid forms and locations. 4. Integrate new relationship logic with model and parser. 5. Add debug output for relationship parsing and mapping. 6. Update documentation to describe relationship handling and edge cases.** | **Unit: Test explicit/implicit relationships, all valid/invalid forms. Edge: Test relationships in groups, nested, implied, circular. Integration: Parse DSLs with complex relationship graphs. Regression: Golden tests for relationship AST output. Coverage: 100% of relationship types and error cases.** | **test('parse_relationship_explicit', () { ... }); test('parse_relationship_implicit', () { ... }); test('parse_relationship_in_group', () { ... }); test('parse_relationship_nested', () { ... }); test('parse_relationship_implied', () { ... }); test('parse_relationship_circular', () { ... }); test('parse_relationship_regression_bugB', () { ... });** | **RelationshipParser.parse(List<Token>): List<RelationshipNode>; RelationshipParser._parseExplicit(List<Token>): RelationshipNode; RelationshipParser._parseImplicit(List<Token>): RelationshipNode; RelationshipParser._parseGroup(List<Token>): void; RelationshipParser._parseNested(List<Token>): void; RelationshipNode.setSource(String): void; RelationshipNode.setDestination(String): void;** |
| `_parseInclude()` | `IncludeParser.parse()` | Dart may conflate file includes and view includes. | Needs clear distinction, more tests | **1. Refactor include parsing logic to clearly distinguish between file includes and view includes, matching Java's approach. 2. Update the AST and model to support both include types. 3. Refactor include resolution logic for recursive and circular includes. 4. Integrate changes with parser and model. 5. Add debug output for include parsing and resolution. 6. Update documentation to describe include handling.** | **Unit: Test file includes, view includes, invalid/missing includes. Edge: Test recursive includes, circular includes, missing files. Integration: Parse DSLs with multiple includes. Regression: Golden tests for include resolution. Coverage: 100% of include scenarios.** | **test('parse_include_file', () { ... }); test('parse_include_view', () { ... }); test('parse_include_invalid', () { ... }); test('parse_include_recursive', () { ... }); test('parse_include_circular', () { ... }); test('parse_include_missing_file', () { ... }); test('parse_include_regression_bugC', () { ... });** | **IncludeParser.parse(List<Token>): List<IncludeNode>; IncludeParser._parseFileInclude(List<Token>): IncludeNode; IncludeParser._parseViewInclude(List<Token>): IncludeNode; IncludeParser._resolveRecursive(List<IncludeNode>): void; IncludeParser._resolveCircular(List<IncludeNode>): void; IncludeNode.setType(IncludeType): void;** |
| `_ParsingContext` enum | `WorkspaceDslContext` | Dart uses enum, Java uses class-based stack for context. | Needs class-based context stack | **1. Refactor context management to use a class-based stack, mirroring Java's context stack. 2. Implement push/pop logic for context transitions. 3. Refactor error recovery logic to leverage the new context stack. 4. Integrate context stack with parser and error handling. 5. Add debug output for all context stack operations. 6. Update documentation to describe context management.** | **Unit: Test all context transitions, stack push/pop, error recovery. Edge: Test invalid context switches, stack underflow/overflow. Integration: Parse DSLs with complex context transitions. Regression: Golden tests for context stack behavior. Coverage: 100% of context code paths.** | **test('context_stack_push_pop', () { ... }); test('context_stack_invalid_transition', () { ... }); test('context_stack_underflow', () { ... }); test('context_stack_overflow', () { ... }); test('context_stack_error_recovery', () { ... }); test('context_stack_regression_bugD', () { ... });** | **ContextStack.push(Context ctx): void; ContextStack.pop(): Context; ContextStack.current(): Context; ContextStack.clear(): void; ContextStack.size(): int;** |
| `WorkspaceNode`, `ModelNode`, etc. | `Workspace` (Java model) | Dart model may lack some advanced features (groups, enterprise, implied rels). | Needs feature audit, add missing features | **1. Audit Java model classes for all features and properties, including groups, enterprise, and implied relationships. 2. Implement missing features in Dart model classes. 3. Refactor model node logic to support advanced features. 4. Integrate new features with parser and builder. 5. Add debug output for model construction. 6. Update documentation to describe model features and logic.** | **Unit: Test all model node types, properties, and relationships. Edge: Test missing/extra properties, implied relationships, group/enterprise. Integration: Parse DSLs with full model features. Regression: Golden tests for model output. Coverage: 100% of model features.** | **test('model_node_person', () { ... }); test('model_node_software_system', () { ... }); test('model_node_group', () { ... }); test('model_node_enterprise', () { ... }); test('model_node_implied_relationships', () { ... }); test('model_node_missing_property', () { ... }); test('model_node_extra_property', () { ... }); test('model_node_regression_bugE', () { ... });** | **ModelNode.addGroup(GroupNode): void; ModelNode.addEnterprise(EnterpriseNode): void; ModelNode.addElement(ElementNode): void; ModelNode.addRelationship(RelationshipNode): void; GroupNode.addElement(ElementNode): void; EnterpriseNode.addGroup(GroupNode): void;** |
| `WorkspaceBuilderImpl` | `WorkspaceBuilder`, `WorkspaceMapper` | Dart may not fully match Java for default behaviors, view population, implied rels. | Needs logic audit, align defaults | **1. Audit Java builder and mapper logic for all default behaviors, including default population and implied relationships. 2. Refactor Dart builder logic to match Java's defaults and advanced features. 3. Update builder interfaces and integration points. 4. Integrate new builder logic with parser and model. 5. Add debug output for builder steps. 6. Update documentation to describe builder logic and defaults.** | **Unit: Test all builder methods, default behaviors, implied rels. Edge: Test missing/extra elements, default population, error cases. Integration: Build workspaces from parsed DSLs and compare to Java output. Regression: Golden tests for builder output. Coverage: 100% of builder logic.** | **test('builder_default_population', () { ... }); test('builder_implied_relationships', () { ... }); test('builder_missing_element', () { ... }); test('builder_extra_element', () { ... }); test('builder_error_case', () { ... }); test('builder_regression_bugF', () { ... });** | **WorkspaceBuilderImpl.addSystemContextView(SystemContextViewNode): void; WorkspaceBuilderImpl.addDefaultElements(SystemContextViewNode): void; WorkspaceBuilderImpl.addImpliedRelationships(): void; WorkspaceBuilderImpl.populateDefaults(): void; WorkspaceBuilderImpl.setDefaultsFromJava(): void;** |
| `addSystemContextView()` in `WorkspaceBuilderImpl` | `SystemContextViewParser` | Dart may not fully match Java for `include *`, default population, advanced view features. | Needs logic audit, align with Java | **1. Audit Java SystemContextViewParser for all view population logic, including handling of `include *`, default population, and advanced features. 2. Refactor Dart view population logic to match Java's approach. 3. Update view builder interfaces and integration points. 4. Integrate new view logic with model and builder. 5. Add debug output for view population. 6. Update documentation to describe view population logic and features.** | **Unit: Test all view population scenarios, include/exclude logic, default population. Edge: Test conflicting includes/excludes, missing/extra elements. Integration: Build and render views from parsed DSLs and compare to Java. Regression: Golden tests for view output. Coverage: 100% of view population logic.** | **test('system_context_view_include_all', () { ... }); test('system_context_view_include_exclude', () { ... }); test('system_context_view_default_population', () { ... }); test('system_context_view_conflicting_rules', () { ... }); test('system_context_view_missing_element', () { ... }); test('system_context_view_regression_bugG', () { ... });** | **SystemContextViewParser.parse(SystemContextViewNode): SystemContextView; SystemContextViewParser.handleIncludeAll(SystemContextViewNode): void; SystemContextViewParser.handleIncludeExclude(SystemContextViewNode): void; SystemContextViewParser.populateDefaults(SystemContextViewNode): void; SystemContextViewParser.setAdvancedFeatures(SystemContextViewNode): void;** |
| Model classes in `lib/domain/model/` | Java model classes | Dart may lack some advanced properties, group/enterprise, implied rels. | Needs audit, add missing features | **1. Audit all Java model classes and properties, including advanced features. 2. Implement missing features in Dart model classes. 3. Refactor model class logic to support new features. 4. Integrate new model logic with parser and builder. 5. Add debug output for model operations. 6. Update documentation to describe model class features and logic.** | **Unit: Test all model class properties, methods, and relationships. Edge: Test missing/extra properties, implied relationships, group/enterprise. Integration: Parse and build models from DSLs and compare to Java. Regression: Golden tests for model serialization. Coverage: 100% of model code.** | **test('model_class_person', () { ... }); test('model_class_software_system', () { ... }); test('model_class_group', () { ... }); test('model_class_enterprise', () { ... }); test('model_class_implied_relationships', () { ... }); test('model_class_missing_property', () { ... }); test('model_class_extra_property', () { ... }); test('model_class_regression_bugH', () { ... });** | **PersonNode.setProperty(String, dynamic): void; SoftwareSystemNode.setProperty(String, dynamic): void; GroupNode.setProperty(String, dynamic): void; EnterpriseNode.setProperty(String, dynamic): void; ModelNode.setAdvancedProperty(String, dynamic): void; ModelNode.addImpliedRelationship(RelationshipNode): void;** |
| View classes in `lib/domain/view/` | Java view classes | Dart may not match Java for population, include/exclude, inheritance. | Needs audit, align logic | **1. Audit all Java view classes and their population logic, including include/exclude and inheritance. 2. Refactor Dart view class logic to match Java's approach. 3. Update view class interfaces and integration points. 4. Integrate new view logic with model and builder. 5. Add debug output for view logic. 6. Update documentation to describe view class features and logic.** | **Unit: Test all view class methods, include/exclude logic, inheritance. Edge: Test conflicting includes/excludes, missing/extra elements, inheritance chains. Integration: Build and render views from parsed DSLs and compare to Java. Regression: Golden tests for view serialization. Coverage: 100% of view code.** | **test('view_class_system_context', () { ... }); test('view_class_container', () { ... }); test('view_class_dynamic', () { ... }); test('view_class_deployment', () { ... }); test('view_class_include_exclude', () { ... }); test('view_class_inheritance', () { ... }); test('view_class_conflicting_rules', () { ... }); test('view_class_regression_bugI', () { ... });** | **SystemContextViewNode.setIncludeRule(IncludeRule): void; SystemContextViewNode.setExcludeRule(ExcludeRule): void; SystemContextViewNode.setInheritance(ViewNode): void; ViewNode.addElement(ElementNode): void; ViewNode.setProperty(String, dynamic): void;** |

---

**Legend:**
- Audit Status: What needs to be done to bring Dart in line with Java for each module.
- Refactoring Plan: Step-by-step, actionable plan for each module.
- Testing Plan: Comprehensive, detailed plan for verifying correctness and parity.
- Testing Methods: List of test methods and their interfaces for each module.
- Comprehensive Implementation Plan: Step-by-step, actionable plan for implementation (no test writing steps).
- Parsing Implementation Methods: List of methods and their interfaces to be written/refactored for each module.
- This table is a living document and should be updated as modules are audited and aligned. 